<!DOCTYPE html>
<html lang="en-US" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.51" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://drmaemi.github.io/blog/blog/computer-science/operating-system/06-threads.html"><meta property="og:site_name" content="Maemi's Devlog"><meta property="og:title" content="[운영체제] 06. 스레드"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-10-15T08:22:29.000Z"><meta property="og:locale" content="en-US"><meta property="article:published_time" content="2022-07-29T00:00:00.000Z"><meta property="article:modified_time" content="2022-10-15T08:22:29.000Z"><link rel="icon" href="/blog/favicon.ico"><link rel="icon" href="/blog/assets/icon/chrome-mask-512.png" type="image/png" sizes="512x512"><link rel="icon" href="/blog/assets/icon/chrome-mask-192.png" type="image/png" sizes="192x192"><link rel="icon" href="/blog/assets/icon/chrome-512.png" type="image/png" sizes="512x512"><link rel="icon" href="/blog/assets/icon/chrome-192.png" type="image/png" sizes="192x192"><link rel="manifest" href="/blog/manifest.webmanifest" crossorigin="use-credentials"><meta name="theme-color" content="#46bd87"><link rel="apple-touch-icon" href="/blog/assets/icon/apple-icon-152.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="msapplication-TileImage" content="/blog/assets/icon/ms-icon-144.png"><meta name="msapplication-TileColor" content="#ffffff"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"><title>[운영체제] 06. 스레드 | Maemi's Devlog</title><meta name="description" content="어려울수록 기본에 미쳐라">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/blog/assets/style.6554ca46.css">
    <link rel="modulepreload" href="/blog/assets/app.70b1b023.js"><link rel="modulepreload" href="/blog/assets/06-threads.html.4a28f41d.js"><link rel="modulepreload" href="/blog/assets/DetailsOpen.d5ab58f9.js"><link rel="modulepreload" href="/blog/assets/_plugin-vue_export-helper.cdc0426e.js"><link rel="modulepreload" href="/blog/assets/06-threads.html.d16a7190.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/blog/" class="brand"><img class="logo" src="/blog/logo.png" alt="Maemi&#39;s Devlog"><!----><span class="site-name hide-in-pad">Maemi&#39;s Devlog</span></a><!----></div><div class="navbar-center"><!----><!----></div><div class="navbar-right"><!----><div id="docsearch-container"></div><div class="nav-item"><a class="repo-link" href="https://github.com/DrMaemi/blog" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><section class="sidebar-group"><p class="sidebar-heading clickable active"><img class="icon" src="/blog/assets/icon/operating-system.png"><a href="/blog/category/operating-system/" class="title">Operating System</a><!----></p><ul class="sidebar-links"><li><!--[--><a href="/blog/computer-science/operating-system/01-os-intro.html" class="nav-link sidebar-link sidebar-page" aria-label="[운영체제] 01. 운영체제란?"><span class="icon iconfont icon-article"></span>[운영체제] 01. 운영체제란?<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/computer-science/operating-system/02-system-call.html" class="nav-link sidebar-link sidebar-page" aria-label="[운영체제] 02. 시스템 콜(System Call)"><span class="icon iconfont icon-article"></span>[운영체제] 02. 시스템 콜(System Call)<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/computer-science/operating-system/03-os-structure.html" class="nav-link sidebar-link sidebar-page" aria-label="[운영체제] 03. 운영체제 구조"><span class="icon iconfont icon-article"></span>[운영체제] 03. 운영체제 구조<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/computer-science/operating-system/04-processes.html" class="nav-link sidebar-link sidebar-page" aria-label="[운영체제] 04. 프로세스 개요"><span class="icon iconfont icon-article"></span>[운영체제] 04. 프로세스 개요<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/computer-science/operating-system/05-ipc.html" class="nav-link sidebar-link sidebar-page" aria-label="[운영체제] 05. 프로세스 간 통신(IPC)"><span class="icon iconfont icon-article"></span>[운영체제] 05. 프로세스 간 통신(IPC)<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="[운영체제] 06. 스레드"><span class="icon iconfont icon-article"></span>[운영체제] 06. 스레드<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_1-스레드-등장-배경" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. 스레드 등장 배경"><!---->1. 스레드 등장 배경<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_2-스레드-thread-란" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2. 스레드(Thread)란?"><!---->2. 스레드(Thread)란?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_3-다중-스레드-프로세스-multi-threaded-process" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3. 다중 스레드 프로세스(Multi-threaded Process)"><!---->3. 다중 스레드 프로세스(Multi-threaded Process)<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_3-다중-스레드의-장점" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3. 다중 스레드의 장점"><!---->3. 다중 스레드의 장점<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_4-프로세스-vs-스레드" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4. 프로세스 vs 스레드"><!---->4. 프로세스 vs 스레드<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_5-동시성-concurrency-vs-병행성-parallelism" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5. 동시성(Concurrency) vs 병행성(Parallelism)"><!---->5. 동시성(Concurrency) vs 병행성(Parallelism)<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_5-1-병행성-종류" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.1. 병행성 종류"><!---->5.1. 병행성 종류<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_5-2-암달의-법칙-amdahl-s-law" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.2. 암달의 법칙(Amdahl&#39;s Law)"><!---->5.2. 암달의 법칙(Amdahl&#39;s Law)<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_6-스레드-구현" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6. 스레드 구현"><!---->6. 스레드 구현<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_6-1-스레드-라이브러리" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.1. 스레드 라이브러리"><!---->6.1. 스레드 라이브러리<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_6-2-사용자-스레드-vs-커널-스레드" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.2. 사용자 스레드 vs 커널 스레드"><!---->6.2. 사용자 스레드 vs 커널 스레드<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_6-3-암묵적-스레딩-implicit-threading" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.3. 암묵적 스레딩(Implicit Threading)"><!---->6.3. 암묵적 스레딩(Implicit Threading)<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_7-스레드-이슈-issues-in-threading" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7. 스레드 이슈(Issues in Threading)"><!---->7. 스레드 이슈(Issues in Threading)<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_7-1-fork-exec" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7.1. fork() &amp; exec()"><!---->7.1. fork() &amp; exec()<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_7-2-signal-handling" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7.2. Signal Handling"><!---->7.2. Signal Handling<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_7-3-스레드-중지-thread-cancellation" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7.3. 스레드 중지(Thread Cancellation)"><!---->7.3. 스레드 중지(Thread Cancellation)<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_7-4-스레드-로컬-스토리지-thread-local-storage-tls" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7.4. 스레드 로컬 스토리지(Thread Local Storage, TLS)"><!---->7.4. 스레드 로컬 스토리지(Thread Local Storage, TLS)<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#a-참조" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="A. 참조"><!---->A. 참조<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/blog/computer-science/operating-system/07-process-scheduling.html" class="nav-link sidebar-link sidebar-page" aria-label="[운영체제] 07. 프로세스 스케줄링"><span class="icon iconfont icon-article"></span>[운영체제] 07. 프로세스 스케줄링<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><span class="icon iconfont icon-article"></span>[운영체제] 06. 스레드</h1><div class="page-info"><span class="author-info" aria-label="Author🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="author-item" href="https://github.com/DrMaemi" target="_blank" rel="noopener noreferrer">Dr.Maemi</a></span><span property="author" content="Dr.Maemi"></span></span><!----><span class="date-info" aria-label="Writing Date📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span>July 29, 2022</span><meta property="datePublished" content="2022-07-29T00:00:00.000Z"></span><span class="category-info" aria-label="Category🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><ul class="categories-wrapper"><li><span class="category category6 clickable" role="navigation">Operating System</span></li></ul><meta property="articleSection" content="Operating System"></span><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">On This Page</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_1-스레드-등장-배경" class="router-link-active router-link-exact-active toc-link level2">1. 스레드 등장 배경</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_2-스레드-thread-란" class="router-link-active router-link-exact-active toc-link level2">2. 스레드(Thread)란?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_3-다중-스레드-프로세스-multi-threaded-process" class="router-link-active router-link-exact-active toc-link level2">3. 다중 스레드 프로세스(Multi-threaded Process)</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_3-다중-스레드의-장점" class="router-link-active router-link-exact-active toc-link level2">3. 다중 스레드의 장점</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_4-프로세스-vs-스레드" class="router-link-active router-link-exact-active toc-link level2">4. 프로세스 vs 스레드</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_5-동시성-concurrency-vs-병행성-parallelism" class="router-link-active router-link-exact-active toc-link level2">5. 동시성(Concurrency) vs 병행성(Parallelism)</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_5-1-병행성-종류" class="router-link-active router-link-exact-active toc-link level3">5.1. 병행성 종류</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_5-2-암달의-법칙-amdahl-s-law" class="router-link-active router-link-exact-active toc-link level3">5.2. 암달의 법칙(Amdahl&#39;s Law)</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_6-스레드-구현" class="router-link-active router-link-exact-active toc-link level2">6. 스레드 구현</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_6-1-스레드-라이브러리" class="router-link-active router-link-exact-active toc-link level3">6.1. 스레드 라이브러리</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_6-2-사용자-스레드-vs-커널-스레드" class="router-link-active router-link-exact-active toc-link level3">6.2. 사용자 스레드 vs 커널 스레드</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_6-3-암묵적-스레딩-implicit-threading" class="router-link-active router-link-exact-active toc-link level3">6.3. 암묵적 스레딩(Implicit Threading)</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_7-스레드-이슈-issues-in-threading" class="router-link-active router-link-exact-active toc-link level2">7. 스레드 이슈(Issues in Threading)</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_7-1-fork-exec" class="router-link-active router-link-exact-active toc-link level3">7.1. fork() &amp; exec()</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_7-2-signal-handling" class="router-link-active router-link-exact-active toc-link level3">7.2. Signal Handling</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_7-3-스레드-중지-thread-cancellation" class="router-link-active router-link-exact-active toc-link level3">7.3. 스레드 중지(Thread Cancellation)</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#_7-4-스레드-로컬-스토리지-thread-local-storage-tls" class="router-link-active router-link-exact-active toc-link level3">7.4. 스레드 로컬 스토리지(Thread Local Storage, TLS)</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/06-threads.html#a-참조" class="router-link-active router-link-exact-active toc-link level2">A. 참조</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><p><em>본문은 2019년도 하반기 아주대학교의 컴퓨터공학과 교수로 재직하셨던 김상훈 교수님의 운영체제 과목 강의 자료를 기반으로 작성되었음을 알립니다.</em></p><h2 id="_1-스레드-등장-배경" tabindex="-1"><a class="header-anchor" href="#_1-스레드-등장-배경" aria-hidden="true">#</a> 1. 스레드 등장 배경</h2><p>기존 프로세스 개념을 이용해 프로그래밍을 하면 다음과 같은 많은 문제가 발생했습니다.</p><ul><li>다중 코어(Multi-cores) 환경에서 단일 프로세스로 실행하는 것은 컴퓨터 자원을 충분히 활용하지 못함</li><li>다른 여러 프로세스와 협업하는 프로그램을 작성하는 것은 매우 힘듬</li><li>새로운 프로세스를 생성하는 데 고비용 <ul><li>fork()를 통해 프로세스를 생성하면 기존 메모리 공간을 통째로 복사해야 함</li></ul></li><li>프로세스 간 통신 시 많은 오버헤드 발생</li></ul><p>그 결과 프로세스 내에서 저비용으로 동시성(Concurrency)를 향상시킬 수 있는 방법을 고민하다가 스레드(Thread) 개념이 등장했습니다.</p><h2 id="_2-스레드-thread-란" tabindex="-1"><a class="header-anchor" href="#_2-스레드-thread-란" aria-hidden="true">#</a> 2. 스레드(Thread)란?</h2><p>스레드는 **프로세스의 실행 제어 정보(Execution state)**를 의미합니다. Thread, A thread of control, A lightweight process(LWP)라고도 합니다.</p><p>프로세스의 구성 요소</p><ul><li>주소 공간(Address space)</li><li>자원(Resources)</li><li>사용자ID, 권한(Previleges)</li><li>실행 제어 정보(Execution state) <ul><li>PC(Program Counter), SP(Stack Point), Registers, etc.</li></ul></li></ul><h2 id="_3-다중-스레드-프로세스-multi-threaded-process" tabindex="-1"><a class="header-anchor" href="#_3-다중-스레드-프로세스-multi-threaded-process" aria-hidden="true">#</a> 3. 다중 스레드 프로세스(Multi-threaded Process)</h2><p>단일 프로세스에서 다중 스레딩을 통해 프로세스를 병렬 처리하여 동시성을 향상시킬 수 있습니다.</p><p>다중 스레드 프로세스는 다음과 같은 특징을 가집니다.</p><ul><li>Thread는 프로세스의 주소 공간 일부를 공유함 <ul><li>Code, Data, Heap 메모리 영역</li><li>PCB 일부(I/O status, Opened files)</li></ul></li><li>Thread는 다음과 같은 것들을 독립적으로 가짐 <ul><li>PC, SP를 포함한 레지스터 집합</li><li>Stack 메모리 영역</li><li>Thread ID</li></ul></li></ul><p class="align-center"><img src="https://drive.google.com/uc?export=view&amp;id=1geXPwVUfEQlqrECOyUhJ_xDp5kfAPdoC" alt="" loading="lazy"> &lt;그림 1. 다중 스레드 프로세스&gt;</p><h2 id="_3-다중-스레드의-장점" tabindex="-1"><a class="header-anchor" href="#_3-다중-스레드의-장점" aria-hidden="true">#</a> 3. 다중 스레드의 장점</h2><ul><li>다중 코어 아키텍처의 성능(Throughput)을 최대로 끌어올릴 수 있음</li><li>프로그래밍 관점에서 자원 공유를 논리적으로 명시 가능</li><li>프로그램 복잡성을 낮춤 <ul><li>규모가 큰 Task를 여러 개의 작은 Task로 나누고, 각 Task를 수행하는 스레드에 바인딩</li></ul></li><li>소프트웨어의 반응성(Responsiveness) 향상 <ul><li>여러 개의 동시 이벤트를 처리하는 웹 서버 등을 구현하는데 필수임</li></ul></li></ul><h2 id="_4-프로세스-vs-스레드" tabindex="-1"><a class="header-anchor" href="#_4-프로세스-vs-스레드" aria-hidden="true">#</a> 4. 프로세스 vs 스레드</h2><p>프로세스와 스레드의 관계는 하나의 프로세스가 하나 이상의 스레드를 포함하는 관계로 다음과 같은 성질을 만족합니다.</p><ul><li>하나의 단일 프로세스에 최소 1개 이상의 스레드가 존재</li><li>단일 프로세스 내 존재하는 모든 스레드는 동일한 프로세스 주소 공간 참조</li><li>CPU 스케줄링의 기본 단위는 프로세스가 아니라 스레드임</li><li>프로세스는 정적(static), 스레드는 동적(dynamic) 특징을 가짐</li></ul><h2 id="_5-동시성-concurrency-vs-병행성-parallelism" tabindex="-1"><a class="header-anchor" href="#_5-동시성-concurrency-vs-병행성-parallelism" aria-hidden="true">#</a> 5. 동시성(Concurrency) vs 병행성(Parallelism)</h2><p>동시성(Concurrency)은 단일 코어 자원을 특정 기준에 따라 분할하여 다중 Task에 할당하며 처리하는 특성을 의미합니다. 반면 병행성(Parallelism)은 다중 코어 자원을 다중 Task에 할당하여 동시(simultaneously)에 처리하는 특성을 의미합니다.</p><p>동시성을 가진 환경에서 실행되는 Task는 병렬적으로 동시에 처리되지 않지만 동시에 처리되는 것처럼 보이게 됩니다.</p><p class="align-center"><img src="https://drive.google.com/uc?export=view&amp;id=1Xyl45sMJDEs9tOYfH_oRLyH5L1CG-oX2" alt="" loading="lazy"> &lt;그림 2. Concurrency&gt;</p><p class="align-center"><img src="https://drive.google.com/uc?export=view&amp;id=1wJk7DJwpekRwVeHlntktPIqRFh6AVf5x" alt="" loading="lazy"> &lt;그림 3. Parallelism&gt;</p><h3 id="_5-1-병행성-종류" tabindex="-1"><a class="header-anchor" href="#_5-1-병행성-종류" aria-hidden="true">#</a> 5.1. 병행성 종류</h3><h4 id="_5-1-1-data-parallelism" tabindex="-1"><a class="header-anchor" href="#_5-1-1-data-parallelism" aria-hidden="true">#</a> 5.1.1. Data parallelism</h4><ul><li>처리가 필요한 데이터 영역을 여러 개의 부분 집합으로 나누고 각 집합을 다중 코어에 할당하는 방식</li><li>다중 코어가 같은 연산을 동시에 수행</li><li>E.g., 배열의 합 처리 시 색인 집합을 나누어 각 부분 집합의 합을 병렬 처리</li></ul><h4 id="_5-1-2-task-parallelism" tabindex="-1"><a class="header-anchor" href="#_5-1-2-task-parallelism" aria-hidden="true">#</a> 5.1.2. Task parallelism</h4><ul><li>서로 다른 기능을 수행중인 여러 스레드를 다중 코어에 할당하는 방식</li><li>다중 코어가 서로 다른 연산을 동시에 수행</li><li>E.g., 데이터의 합과 표준 편차를 구하는 연산을 수행하는 두 스레드를 각 코어에 할당하여 처리</li></ul><h3 id="_5-2-암달의-법칙-amdahl-s-law" tabindex="-1"><a class="header-anchor" href="#_5-2-암달의-법칙-amdahl-s-law" aria-hidden="true">#</a> 5.2. 암달의 법칙(Amdahl&#39;s Law)</h3><p>프로그램 작성 시 Serial한 부분과 Parallel한 부분으로 나눌 수 있는데, 전체 프로그램 동작이 전부 Serial 할 때 성능을 1이라 했을 때 Parallel 처리를 적용함으로써 최대 얼마나 성능 향상이 가능할지 계산하는 수식을 암달의 법칙(Amdahl&#39;s Law)라 합니다.</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>s</mi><mi>p</mi><mi>e</mi><mi>e</mi><mi>d</mi><mi>u</mi><mi>p</mi><mo>≤</mo><mfrac><mn>1</mn><mrow><mi>S</mi><mo>+</mo><mfrac><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><mi>N</mi></mfrac></mrow></mfrac></mrow><annotation encoding="application/x-tex"> speedup \le \frac{1}{S+\frac{(1-S)}{N}} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal">ee</span><span class="mord mathnormal">d</span><span class="mord mathnormal">u</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.5664em;vertical-align:-1.245em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.11em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.24em;"><span class="pstrut" style="height:3.01em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.687em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.245em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p class="align-center">&lt;수식 1. 암달의 법칙(Amdahl&#39;s Law)&gt;</p><p>프로그램의 전체를 1이라 하면 그 중 Serial한 부분의 비율을 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>, Parallel한 부분의 비율은 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">1-S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>, 시스템의 코어 수를 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>이라 했을 때 위 수식을 통해서 최대 얼마나 성능 향상이 기대되는지 계산할 수 있습니다.</p><h2 id="_6-스레드-구현" tabindex="-1"><a class="header-anchor" href="#_6-스레드-구현" aria-hidden="true">#</a> 6. 스레드 구현</h2><h3 id="_6-1-스레드-라이브러리" tabindex="-1"><a class="header-anchor" href="#_6-1-스레드-라이브러리" aria-hidden="true">#</a> 6.1. 스레드 라이브러리</h3><p>다중 스레드 프로그래밍은 보통 OS나 프로그래밍 언어가 지원하는 라이브러리를 사용하여 진행합니다. 스레드 라이브러리는 프로그래머가 스레드를 생성하거나 관리할 수 있도록 하는 API를 제공합니다.</p><p>스레드 라이브러리는 유닉스 계열 운영체제가 사용하는 Pthreads(POSIX Threads) 뿐 아니라 윈도우 계열 운영체제, 자바와 같은 프로그래밍 언어에서 지원합니다.</p><h3 id="_6-2-사용자-스레드-vs-커널-스레드" tabindex="-1"><a class="header-anchor" href="#_6-2-사용자-스레드-vs-커널-스레드" aria-hidden="true">#</a> 6.2. 사용자 스레드 vs 커널 스레드</h3><p>개발자가 스레드 라이브러리를 통해 직접 생성하고 관리하는 스레드를 사용자 스레드(User Thread), 운영체제에 의해 생성되고 관리되는 스레드를 커널 스레드(Kernel Thread)라 합니다.</p><div class="align-center"><table><thead><tr><th style="text-align:center;">관점</th><th style="text-align:center;">사용자 스레드</th><th style="text-align:center;">커널 스레드</th></tr></thead><tbody><tr><td style="text-align:center;">구현 주체</td><td style="text-align:center;">개발자(사용자)</td><td style="text-align:center;">운영체제</td></tr><tr><td style="text-align:center;">인식</td><td style="text-align:center;">OS는 사용자 스레드의 존재를 모름</td><td style="text-align:center;">OS 커널 스레드를 생성 및 관리</td></tr><tr><td style="text-align:center;">구현 난이도</td><td style="text-align:center;">쉬움</td><td style="text-align:center;">어려움</td></tr><tr><td style="text-align:center;">Context switch 성능</td><td style="text-align:center;">빠름</td><td style="text-align:center;">느림</td></tr><tr><td style="text-align:center;">하드웨어 지원 필요 유무</td><td style="text-align:center;">필요 없음</td><td style="text-align:center;">필요</td></tr><tr><td style="text-align:center;">Blocking</td><td style="text-align:center;">스레드 중 하나라도 Blocking되면 시스템 전체가 Block됨(Many-to-One 모델)</td><td style="text-align:center;">스레드 중 하나가 Block되더라도 나머지 스레드는 실행 가능</td></tr><tr><td style="text-align:center;">다중 스레딩</td><td style="text-align:center;">커널 스레드의 지원 없이는 멀티프로세싱의 이점을 가질 수 없음</td><td style="text-align:center;">멀티프로세싱 이점을 가짐(실제 OS의 스케줄링 단위)</td></tr><tr><td style="text-align:center;">OS 의존</td><td style="text-align:center;">어떤 OS 환경에서라도 동작 가능</td><td style="text-align:center;">구현된 스레드는 OS에 종속적으로 동작</td></tr><tr><td style="text-align:center;">제어</td><td style="text-align:center;">스레드 라이브러리가 스레드 생성, 메시지 패싱, 스케줄링 등을 모두 구현</td><td style="text-align:center;">어플리케이션은 커널 스레드를 직접 제어하지 못하고 API를 통해 기능 호출</td></tr><tr><td style="text-align:center;">종류</td><td style="text-align:center;">Java thread, POSIX thread</td><td style="text-align:center;">Window Solaris</td></tr></tbody></table></div><p>OS에 따라 사용자 스레드를 지원하기 위한 커널 스레드 생성 및 관리 정책이 모두 다릅니다. 스레드 생성 및 관리 정책은 사용자 스레드-커널 스레드 간 연관 관계에 따라 One-to-One, Many-to-One, Many-to-Many, 여러 정책을 혼용해서 사용하는 Two-level Model로 분류할 수 있습니다.</p><p>오늘날 대부분의 OS는 하나의 사용자 스레드 생성에 하나의 커널 스레드가 생성되어 매핑되는 One-to-One 모델을 사용합니다. One-to-One 모델은 사용자 스레드 수 증가에 따라 커널 스레드도 증가하여 오버헤드가 발생하는 것을 방지하고자 일정 수 이상 스레드 생성을 제한합니다.</p><h3 id="_6-3-암묵적-스레딩-implicit-threading" tabindex="-1"><a class="header-anchor" href="#_6-3-암묵적-스레딩-implicit-threading" aria-hidden="true">#</a> 6.3. 암묵적 스레딩(Implicit Threading)</h3><p>Implicit Threading은 스레드의 생성과 관리 책임을 개발자가 갖는 것이 아니라 컴파일러와 런타임 라이브러리가 갖는 것을 의미합니다. 개발자는 병렬로 실행할 수 있는 작업만 식별해서 작업을 함수로 작성하면 런타임 라이브러리를 통해 가용 스레드에 매핑되는 방식으로 동작합니다.</p><p>다중 스레드 프로그래밍 시 명시적 스레딩(Explicit Threading) 기법을 통해 개발자가 직접 스레드를 생성하고 관리하자 스레드 수 증가에 따라 프로그램의 복잡도가 증가하면서 프로그래밍에 많은 어려움이 생기는데 이를 암묵적 스레딩을 통해 해결할 수 있습니다.</p><p>결과적으로 스레드 생성과 관리를 시스템에 위임하고 어플리케이션은 필요 작업을 라이브러리를 통해 스레드에 매핑만 하면 됩니다.</p><h4 id="_6-3-1-thread-pool" tabindex="-1"><a class="header-anchor" href="#_6-3-1-thread-pool" aria-hidden="true">#</a> 6.3.1. Thread Pool</h4><p>웹 서버에서 모든 요 청마다 새로운 스레드를 만들어 서비스를 제공한다면 시스템에 무한한 스레드가 생성되면서 많은 오버헤드가 발생하는데, 이런 문제를 해결하는 방법이 Thread Pool입니다. Thread Pool은 프로세스를 시작할 때 일정 수의 스레드를 미리 생성해두는 방식으로, 스레드가 많이 담긴 수영장이라고 쉽게 생각할 수 있습니다.</p><p class="align-center"><img src="https://drive.google.com/uc?export=view&amp;id=1dAObUS4hfpTXC1rmPAD2Gfrea0l-7F4k" alt="" loading="lazy"> &lt;그림 4. Thread Pool&gt;</p><p>Thread Pool은 다음과 같은 특징을 가집니다.</p><ul><li>시스템은 요청을 받으면 새로운 스레드를 생성하는 것이 아니라 사용중이지 않은 스레드에 요청을 바인딩함</li><li>모든 스레드가 사용중이라면 사용 가능한 스레드가 생길 때까지 작업을 대기함</li><li>새로운 스레드를 생성하는 방식에 비해 일반적으로 요청 처리 성능이 향상됨</li></ul><p>프로그래밍할 때 스레드의 생성, 삭제가 잦거나 얼마나 많은 스레드가 필요할지 예측하기 힘들 때 Thread Pool 기법을 사용하면 좋습니다.</p><h4 id="_6-3-2-fork-join" tabindex="-1"><a class="header-anchor" href="#_6-3-2-fork-join" aria-hidden="true">#</a> 6.3.2. Fork Join</h4><p>부모 스레드(메인 스레드) 하나 이상의 자식 스레드를 fork한 뒤 종료를 기다린 후 join하는 시점에 자식 스레드의 처리 결과를 확인하고 결합하는 방식을 Fork Join이라 합니다. 프로그램 런타임은 생성되는 스레드 수를 관리하고 작업을 배정합니다. 쉽게 생각해서 Fork Join은 런타임 라이브러리가 생성할 실제 스레드 수를 프로그램 상황에 따라 동기적으로 결정하는 Thread Pool입니다.</p><p class="align-center"><img src="https://drive.google.com/uc?export=view&amp;id=1mj1feiH9FUb5yF3dE-ArHlOl2NJYXxN3" alt="" loading="lazy"> &lt;그림 5. Fork Join&gt;</p><p>이전 pThread의 Fork-join과 같은 모델이기 때문에 명시적 스레딩으로 착각할 수 있으나 이 Fork Join 기법은 Fork와 Join 시점을 런타임 라이브러리가 제어하므로 엄연히 암묵적 스레딩에 해당됩니다.</p><h4 id="_6-3-3-openmp" tabindex="-1"><a class="header-anchor" href="#_6-3-3-openmp" aria-hidden="true">#</a> 6.3.3. OpenMP</h4><p>OpenMP는 공유 메모리 환경에서 코드 블럭의 병렬 실행을 가능하게 하는 기법으로, <code>#pragma omp parallel</code>과 같은 컴파일러 지시문(Compiler Directives)을 사용합니다.</p><details class="custom-container details"><summary>OpenMP 예제</summary><!----></details><p>:::</p><p>PC(Program Counter)가 OpenMP 지시문 <code>#pragma omp parallel for</code>를 만나면 시스템 코어 수만큼 스레드를 생성하고 해당 블럭을 병렬로 실행합니다. <code>i</code>번 째 반복문의 코드 블럭이 임의의 스레드에 할당되어 출력문이 생성됩니다.</p><h4 id="_6-3-4-그-외-종류" tabindex="-1"><a class="header-anchor" href="#_6-3-4-그-외-종류" aria-hidden="true">#</a> 6.3.4. 그 외 종류</h4><ul><li><p>Grand Central Dispatch(GCD)</p><ul><li>Apple 사에서 MacOS , iOS를 위해 개발한 스레딩 기술</li><li>개발자가 병렬로 실행할 코드 블럭을 식별해서 라이브러리에 전달</li><li>Serial Queue, Concurrent Queue 자료구조 사용</li></ul></li><li><p>Intel Thread Building Blocks(TBB)</p><ul><li>C++에서 병렬 프로그램 설계를 지원하는 템플릿 라이브러리</li><li>특별한 컴파일러나 언어 지원이 필요하지 않음</li></ul></li></ul><h2 id="_7-스레드-이슈-issues-in-threading" tabindex="-1"><a class="header-anchor" href="#_7-스레드-이슈-issues-in-threading" aria-hidden="true">#</a> 7. 스레드 이슈(Issues in Threading)</h2><p>다중 스레드 프로그램에서 발생하는 이슈들 몇 가지에 대해서 생각해봅시다.</p><h3 id="_7-1-fork-exec" tabindex="-1"><a class="header-anchor" href="#_7-1-fork-exec" aria-hidden="true">#</a> 7.1. fork() &amp; exec()</h3><p>exec()은 기존 프로세스 메모리 영역이 새로운 프로세스에 의해 완전히 덮어씌워지는 반면 fork()는 새로운 프로세스가 복제되므로 이 때 생성된 프로세스가 기존 프로세스의 모든 스레드를 복제할 것인지, 아니면 fork()를 호출한 스레드 하나만 복제할 것인지 고민할 수 있습니다. 이런 이슈를 해결하기 위해 일부 UNIX 시스템은 각 경우에 해당하는 fork() API를 제공합니다.</p><ul><li>fork() - 부모 프로세스의 모든 스레드 복제</li><li>fork1() - 호출한 스레드만 복제</li></ul><h3 id="_7-2-signal-handling" tabindex="-1"><a class="header-anchor" href="#_7-2-signal-handling" aria-hidden="true">#</a> 7.2. Signal Handling</h3><p>특정 프로세스로 Signal을 전달할 때 어떤 스레드로 전달해야 하는지 고민할 수 있습니다. 정답이 있는 것은 아니지만 대표적으로 다음과 같은 처리 방식을 따를 수 있습니다.</p><ul><li>프로세스 내 아무 스레드가 처리(신경 안씀)</li><li>프로세스 내 시그널 핸들링 로직을 구현해서 어떤 스레드가 어떤 시그널을 담당할지 명시</li><li>프로세스 내 모든 스레드에 시그널 전파</li></ul><h3 id="_7-3-스레드-중지-thread-cancellation" tabindex="-1"><a class="header-anchor" href="#_7-3-스레드-중지-thread-cancellation" aria-hidden="true">#</a> 7.3. 스레드 중지(Thread Cancellation)</h3><p>스레드가 동작을 완료하기 전에 스레드를 중지시키는 방법에 대한 고민이 있을 수 있습니다. 크게 두 가지 방식으로 구현합니다.</p><ul><li>비동기적 중지(Asynchronous cancellation) <ul><li>즉시(Immediategly) 대상 스레드를 중지시킴</li><li>중지된 스레드가 점유/공유하고 있던 자원에 대한 처리를 구현해야 함</li></ul></li><li>중지 연기(Deferred Cancellation) <ul><li>특정 중지 시점(Cancellation Point)에서 대상 스레드를 중지시킴</li><li>주기적으로 스레드 자신이 종료되어야 하는지 확인</li></ul></li></ul><h3 id="_7-4-스레드-로컬-스토리지-thread-local-storage-tls" tabindex="-1"><a class="header-anchor" href="#_7-4-스레드-로컬-스토리지-thread-local-storage-tls" aria-hidden="true">#</a> 7.4. 스레드 로컬 스토리지(Thread Local Storage, TLS)</h3><p>프로세스의 전역 변수는 Data 메모리 영역으로 프로세스 내 모든 스레드가 공유하게 되는데, 이 때 각 스레드 별로 고유 전역 변수를 사용하기 어렵다는 문제를 해결하기 위해 TLS 개념이 필요합니다. TLS는 스레드 고유 전역 변수 공간이라고 생각할 수 있습니다.</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">int</span> global_var <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 전역 변수(Data 영역) - 공유됨</span>
__thread <span class="token keyword">int</span> TLS_var <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 스레드 고유 전역 변수(TLS) - 공유되지 않음</span>

<span class="token function">thread_A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> var_stack <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 스레드 A의 지역 변수(Stack 영역) - 공유되지 않음</span>
    global_var <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span> <span class="token comment">// 전역 변수 조작</span>
    TLS_var <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span> <span class="token comment">// 스레드 고유 전역 변수 조작</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;In thread A, values: %d %d %d&quot;</span><span class="token punctuation">,</span> var_stack<span class="token punctuation">,</span> global_var<span class="token punctuation">,</span> TLS_var<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">thread_B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> var_stack <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">// 스레드 B의 지역 변수(Stack 영역) - 공유되지 않음</span>
    global_var <span class="token operator">=</span> <span class="token number">21</span><span class="token punctuation">;</span> <span class="token comment">// 전역 변수 조작</span>
    TLS_var <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span> <span class="token comment">// 스레드 고유 전역 변수 조작</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;In thread B, values: %d %d %d&quot;</span><span class="token punctuation">,</span> var_stack<span class="token punctuation">,</span> global_var<span class="token punctuation">,</span> TLS_var<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>TLS 구현 방법에 대해 조사하다 보니 Private 힙도 아니고 Stack도 아니고 별도의 저장 공간에 각 스레드가 고유하게 사용할 수 있는 배열 자료구조를 구현하여 사용하는 것으로 이해했습니다(자세한 설명은 <a href="https://docs.microsoft.com/ko-kr/windows/win32/procthread/thread-local-storage?redirectedfrom=MSDN" target="_blank" rel="noopener noreferrer">MS 스레드 로컬 스토리지<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 문서 참조).</p><h2 id="a-참조" tabindex="-1"><a class="header-anchor" href="#a-참조" aria-hidden="true">#</a> A. 참조</h2><div style="text-align:left;"><p>lcy960729, &quot;Implicit Threading (암묵적 스레딩),&quot; <em><a href="http://Velog.io" target="_blank" rel="noopener noreferrer">Velog.io<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></em>, Aug. 4, 2021. [Online]. Available: <a href="https://velog.io/@lcy960729/Implicit-Threading-%EC%95%94%EB%AC%B5%EC%A0%81-%EC%8A%A4%EB%A0%88%EB%94%A9" target="_blank" rel="noopener noreferrer">https://velog.io/@lcy960729/Implicit-Threading-암묵적-스레딩<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> [Accessed Jul. 29, 2022].</p><p>GeeksforGeeks, &quot;Difference between User Level thread and Kernel Level thread,&quot; <em><a href="http://geeksforgeeks.org" target="_blank" rel="noopener noreferrer">geeksforgeeks.org<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></em>, Jul. 1, 2022. [Online]. Available: <a href="https://www.geeksforgeeks.org/difference-between-user-level-thread-and-kernel-level-thread/" target="_blank" rel="noopener noreferrer">https://www.geeksforgeeks.org/difference-between-user-level-thread-and-kernel-level-thread/<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> [Accessed Jul. 29, 2022].</p><p>Microsoft, &quot;스레드 로컬 스토리지,&quot; <em><a href="http://docs.microsoft.com" target="_blank" rel="noopener noreferrer">docs.microsoft.com<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></em>, Jun. 22, 2022. [Online]. Available: <a href="https://docs.microsoft.com/ko-kr/windows/win32/procthread/thread-local-storage?redirectedfrom=MSDN" target="_blank" rel="noopener noreferrer">https://docs.microsoft.com/ko-kr/windows/win32/procthread/thread-local-storage?redirectedfrom=MSDN<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> [Accessed Jul. 29, 2022].</p></div></div><!----><footer class="page-meta"><!----><div class="meta-item update-time"><span class="label">Last update: </span><!----></div><div class="meta-item contributors"><span class="label">Contributors: </span><!--[--><!--[--><span class="contributor" title="email: leesh1510@ajou.ac.kr">DrMaemi</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/blog/computer-science/operating-system/05-ipc.html" class="nav-link prev" aria-label="[운영체제] 05. 프로세스 간 통신(IPC)"><div class="hint"><span class="arrow left"></span>Prev</div><div class="link"><span class="icon iconfont icon-article"></span>[운영체제] 05. 프로세스 간 통신(IPC)</div></a><a href="/blog/computer-science/operating-system/07-process-scheduling.html" class="nav-link next" aria-label="[운영체제] 07. 프로세스 스케줄링"><div class="hint">Next<span class="arrow right"></span></div><div class="link">[운영체제] 07. 프로세스 스케줄링<span class="icon iconfont icon-article"></span></div></a></nav><div class="giscus-wrapper input-top" style="display:block;"><div style="text-align:center">Loading...</div></div><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">MIT Licensed | Copyright © 2022-present Dr.Maemi</div><!----></footer><!--]--></div><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/blog/assets/app.70b1b023.js" defer></script>
  </body>
</html>
