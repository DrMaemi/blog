<!DOCTYPE html>
<html lang="en-US" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.51" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://drmaemi.github.io/blog/blog/computer-science/operating-system/07-process-scheduling.html"><meta property="og:site_name" content="Maemi's Devlog"><meta property="og:title" content="[운영체제] 07. 프로세스 스케줄링"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-10-15T08:22:29.000Z"><meta property="og:locale" content="en-US"><meta property="article:published_time" content="2022-08-03T00:00:00.000Z"><meta property="article:modified_time" content="2022-10-15T08:22:29.000Z"><link rel="icon" href="/blog/favicon.ico"><link rel="icon" href="/blog/assets/icon/chrome-mask-512.png" type="image/png" sizes="512x512"><link rel="icon" href="/blog/assets/icon/chrome-mask-192.png" type="image/png" sizes="192x192"><link rel="icon" href="/blog/assets/icon/chrome-512.png" type="image/png" sizes="512x512"><link rel="icon" href="/blog/assets/icon/chrome-192.png" type="image/png" sizes="192x192"><link rel="manifest" href="/blog/manifest.webmanifest" crossorigin="use-credentials"><meta name="theme-color" content="#46bd87"><link rel="apple-touch-icon" href="/blog/assets/icon/apple-icon-152.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="msapplication-TileImage" content="/blog/assets/icon/ms-icon-144.png"><meta name="msapplication-TileColor" content="#ffffff"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"><title>[운영체제] 07. 프로세스 스케줄링 | Maemi's Devlog</title><meta name="description" content="어려울수록 기본에 미쳐라">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/blog/assets/style.733bb300.css">
    <link rel="modulepreload" href="/blog/assets/app.4c26a6ee.js"><link rel="modulepreload" href="/blog/assets/07-process-scheduling.html.23474794.js"><link rel="modulepreload" href="/blog/assets/UmlScript.44c1627f.js"><link rel="modulepreload" href="/blog/assets/_plugin-vue_export-helper.cdc0426e.js"><link rel="modulepreload" href="/blog/assets/07-process-scheduling.html.f4406420.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/blog/" class="brand"><img class="logo" src="/blog/logo.png" alt="Maemi&#39;s Devlog"><!----><span class="site-name hide-in-pad">Maemi&#39;s Devlog</span></a><!----></div><div class="navbar-center"><!----><!----></div><div class="navbar-right"><!----><div id="docsearch-container"></div><div class="nav-item"><a class="repo-link" href="https://github.com/DrMaemi/blog" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><section class="sidebar-group"><p class="sidebar-heading clickable active"><img class="icon" src="/blog/assets/icon/operating-system.png"><a href="/blog/category/operating-system/" class="title">Operating System</a><!----></p><ul class="sidebar-links"><li><!--[--><a href="/blog/computer-science/operating-system/01-os-intro.html" class="nav-link sidebar-link sidebar-page" aria-label="[운영체제] 01. 운영체제란?"><span class="icon iconfont icon-article"></span>[운영체제] 01. 운영체제란?<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/computer-science/operating-system/02-system-call.html" class="nav-link sidebar-link sidebar-page" aria-label="[운영체제] 02. 시스템 콜(System Call)"><span class="icon iconfont icon-article"></span>[운영체제] 02. 시스템 콜(System Call)<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/computer-science/operating-system/03-os-structure.html" class="nav-link sidebar-link sidebar-page" aria-label="[운영체제] 03. 운영체제 구조"><span class="icon iconfont icon-article"></span>[운영체제] 03. 운영체제 구조<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/computer-science/operating-system/04-processes.html" class="nav-link sidebar-link sidebar-page" aria-label="[운영체제] 04. 프로세스 개요"><span class="icon iconfont icon-article"></span>[운영체제] 04. 프로세스 개요<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/computer-science/operating-system/05-ipc.html" class="nav-link sidebar-link sidebar-page" aria-label="[운영체제] 05. 프로세스 간 통신(IPC)"><span class="icon iconfont icon-article"></span>[운영체제] 05. 프로세스 간 통신(IPC)<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/computer-science/operating-system/06-threads.html" class="nav-link sidebar-link sidebar-page" aria-label="[운영체제] 06. 스레드"><span class="icon iconfont icon-article"></span>[운영체제] 06. 스레드<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="[운영체제] 07. 프로세스 스케줄링"><span class="icon iconfont icon-article"></span>[운영체제] 07. 프로세스 스케줄링<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#_1-프로세스-실행-특징" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. 프로세스 실행 특징"><!---->1. 프로세스 실행 특징<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#_2-프로세스-스케줄링이란" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2. 프로세스 스케줄링이란?"><!---->2. 프로세스 스케줄링이란?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#_2-문맥-교환-context-switch" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2. 문맥 교환(Context-switch)"><!---->2. 문맥 교환(Context-switch)<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#_3-스케줄링-시점과-개요" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3. 스케줄링 시점과 개요"><!---->3. 스케줄링 시점과 개요<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#_4-스케줄링-성능-지표-기준-criteria" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4. 스케줄링 성능 지표(기준, Criteria)"><!---->4. 스케줄링 성능 지표(기준, Criteria)<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#_5-기아와-선점형-스케줄링" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5. 기아와 선점형 스케줄링"><!---->5. 기아와 선점형 스케줄링<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#_6-스케줄링-알고리즘" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6. 스케줄링 알고리즘"><!---->6. 스케줄링 알고리즘<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#_6-1-fcfs" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.1. FCFS"><!---->6.1. FCFS<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#_6-2-sjf" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.2. SJF"><!---->6.2. SJF<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#_6-3-srtf" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.3. SRTF"><!---->6.3. SRTF<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#rr" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="RR"><!---->RR<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#다단계-큐" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="다단계 큐"><!---->다단계 큐<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#다단계-피드백-큐" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="다단계 피드백 큐"><!---->다단계 피드백 큐<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><span class="icon iconfont icon-article"></span>[운영체제] 07. 프로세스 스케줄링</h1><div class="page-info"><span class="author-info" aria-label="Author🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="author-item" href="https://github.com/DrMaemi" target="_blank" rel="noopener noreferrer">Dr.Maemi</a></span><span property="author" content="Dr.Maemi"></span></span><!----><span class="date-info" aria-label="Writing Date📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span>August 3, 2022</span><meta property="datePublished" content="2022-08-03T00:00:00.000Z"></span><span class="category-info" aria-label="Category🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><ul class="categories-wrapper"><li><span class="category category6 clickable" role="navigation">Operating System</span></li></ul><meta property="articleSection" content="Operating System"></span><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">On This Page</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#_1-프로세스-실행-특징" class="router-link-active router-link-exact-active toc-link level2">1. 프로세스 실행 특징</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#_2-프로세스-스케줄링이란" class="router-link-active router-link-exact-active toc-link level2">2. 프로세스 스케줄링이란?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#_2-문맥-교환-context-switch" class="router-link-active router-link-exact-active toc-link level2">2. 문맥 교환(Context-switch)</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#_3-스케줄링-시점과-개요" class="router-link-active router-link-exact-active toc-link level2">3. 스케줄링 시점과 개요</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#_4-스케줄링-성능-지표-기준-criteria" class="router-link-active router-link-exact-active toc-link level2">4. 스케줄링 성능 지표(기준, Criteria)</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#_5-기아와-선점형-스케줄링" class="router-link-active router-link-exact-active toc-link level2">5. 기아와 선점형 스케줄링</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#_6-스케줄링-알고리즘" class="router-link-active router-link-exact-active toc-link level2">6. 스케줄링 알고리즘</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#_6-1-fcfs" class="router-link-active router-link-exact-active toc-link level3">6.1. FCFS</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#_6-2-sjf" class="router-link-active router-link-exact-active toc-link level3">6.2. SJF</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#_6-3-srtf" class="router-link-active router-link-exact-active toc-link level3">6.3. SRTF</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#rr" class="router-link-active router-link-exact-active toc-link level3">RR</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#다단계-큐" class="router-link-active router-link-exact-active toc-link level3">다단계 큐</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/computer-science/operating-system/07-process-scheduling.html#다단계-피드백-큐" class="router-link-active router-link-exact-active toc-link level3">다단계 피드백 큐</a></li><!----><!--]--></ul><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><p><em>본문은 2019년도 하반기 아주대학교의 컴퓨터공학과 교수로 재직하셨던 김상훈 교수님의 운영체제 과목 강의 자료를 기반으로 작성되었음을 알립니다.</em></p><h2 id="_1-프로세스-실행-특징" tabindex="-1"><a class="header-anchor" href="#_1-프로세스-실행-특징" aria-hidden="true">#</a> 1. 프로세스 실행 특징</h2><p>프로세스는 I/O 작업 빈도와 실행 시간에 따라 자원 사용량(CPU Burst 등)이 변합니다.</p><ul><li>I/O 작업 빈도가 높을 수록 CPU를 사용하지 않는 Idle 상태가 많음</li><li>프로세스 실행 직후 첫 5ms 정도까지 CPU 사용 최대화</li></ul><p class="align-center"><img src="https://drive.google.com/uc?export=view&amp;id=1p22CCZUru6xkqepN3WsTHQL9iM-B4Ieb" alt="" loading="lazy"> &lt;그림 1. 프로세스 실행 특징 - CPU-bound vs IO-bound&gt;</p><p class="align-center"><img src="https://drive.google.com/uc?export=view&amp;id=1h219IifMzdR4hVc-mFfbeuuIBpASXimD" alt="" loading="lazy"> &lt;그림 2. 프로세스 실행 특징 - CPU frequency by burst duration&gt;</p><h2 id="_2-프로세스-스케줄링이란" tabindex="-1"><a class="header-anchor" href="#_2-프로세스-스케줄링이란" aria-hidden="true">#</a> 2. 프로세스 스케줄링이란?</h2><p>프로세스 스케줄링(Process Scheduling)이란 언제, 어떤 프로세스에 자원을 할당할지 결정하는 것을 의미합니다. 프로세스 스케줄링의 목적은 <strong>CPU와 같은 자원의 사용률을 최대화하는 것</strong>입니다. 프로세스를 실행하는 자원이 보통 CPU이기 때문에 CPU 스케줄링이라고도 합니다.</p><p>프로세스 스케줄링은 다음과 같은 기능을 수행합니다.</p><ul><li>스케줄링의 대상이 될 가용 프로세스 관리</li><li>다음으로 실행할 프로세스 결정</li><li>프로세스 간 전환(문맥 교환)</li></ul><h2 id="_2-문맥-교환-context-switch" tabindex="-1"><a class="header-anchor" href="#_2-문맥-교환-context-switch" aria-hidden="true">#</a> 2. 문맥 교환(Context-switch)</h2><p>프로세스 간 전환 시 전 프로세스나 앞으로 실행할 프로세스의 상태를 저장해놓은 데이터를 문맥(Context)라 합니다. 이 데이터는 프로세스 제어 블록(PCB, Process Control Block)에 저장되어 있습니다. 프로세스 전환 시 이 Context를 교환하여 실행중이던 프로세스의 데이터와 상태를 저장하고, 다음으로 실행할 프로세스의 지난 데이터와 상태를 불러와 작업을 이어 진행할 수 있게 됩니다.</p><p>그런데 이 문맥 교환을 하는 중에는 CPU를 사용하지 않는 idle 상태가 됩니다. 프로세스 스케줄링의 목적이 CPU의 사용률을 최대화하는 것이므로 적절한 빈도로 문맥 교환을 하여 idle 상태의 시간을 최소화하는 것이 좋습니다.</p><p class="align-center"><img src="https://drive.google.com/uc?export=view&amp;id=1VBRL0FPgR3VRtsmgmDO6Zk03aS7XCBm2" alt="" loading="lazy"> &lt;그림 3. 문맥 교환(Context-switch)&gt;</p><h2 id="_3-스케줄링-시점과-개요" tabindex="-1"><a class="header-anchor" href="#_3-스케줄링-시점과-개요" aria-hidden="true">#</a> 3. 스케줄링 시점과 개요</h2><p>프로세스 스케줄링 시점은 프로세스 상태 다이어그램에서 상태 전이에 해당하는 모든 구간에 해당합니다.</p><div class="mxgraph" style="max-width:100%;margin:auto;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-08-02T12:25:17.916Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36\&quot; etag=\&quot;inJpRCsXFW5pH1QNhoLQ\&quot; version=\&quot;20.2.2\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;bzSGDfPCPLQ6wK0j2PPz\&quot; name=\&quot;Page-1\&quot;&gt;7Ztbc6M2FMc/jR/rQTcEj7ltd2e6babJTPZVBtlWC8gD8i2fvsIIbBCOSeqYJLYnD3AQB9Dvr4N0Dhmgm3j1e8pm058y5NEAOuFqgG4HEAIM4SD/c8J1YaEEF4ZJKkLTaGt4EM/cGB1jnYuQZ7WGSspIiVndGMgk4YGq2ViaymW92VhG9avO2IRbhoeARbb1SYRqWlg9SLf271xMpuWVgesXR2JWNjZPkk1ZKJc7JnQ3QDeplKrYilc3PMo7r+yX4rxve45WN5byRHU5IXt8+gWvfv18Hl3/c7eYPD3yyY/fjJcFi+bmgf/kS3O/al12gnak+1vvXC+nQvGHGQvyI0uNXNumKo70HtCbY5mobywWUU77O48WXImA6QOZSuW/VQ9umoooupGRTDeXQGMv4EFgXBgZALc6c6flyCOYOPqIuXWeKr7a2yeg6mktUS5jrtK1bmJO8AybdX13uSXtG9N0B7JrbMxoa1L53Xa/3jAEXkEDWjT+5ixc98JjzN1uPELqj5wj8YBOHQjomwiyicyTRCSTPpiEjHvjTkzcwOOj8XGYYPTBmGCLyRMTqicm4/EYdhwn7sgl7nGYIIBrTJDTMxNiMXnkaSwSpnjYy1Ah3AtxFyweHCH3SFgI+VjvE9eiYrNIwqt8mqT3gohlmQg6Imh2rHZkdvO9YJ4ueGh8FBfloTXTavSrvjE5TwN+eL6iWDrh6tCb1Oa0A4K0gChtKY+YEov67bbRMVe4l0I/yHZ0wroMIGoALh7TnLU7ZWs6ontCb+mo6AfL0UYs1WO/XT/0y+kHfQb9ABcNAQCQUoB8nzg+rasAoyHWQcPF0EPQh9h7m7p04Bl6nkd1nHIdB/uNdwrw3SGhyEeEApc6lMBO2tNqYOudZrO8QfbCYHEbGke1ZYzeKDweVdje2Qob9xoYG/GsWhu/WrrYH9L8hxFFgHqw4ZYMqee6BFDgU0w98i7KxY3VIwInUK7/5ZQLOyoX9ancat5WSgy/UbnYOTAE3imsQnoCcZZJuy+kTvwZJgxVtrQB+/UTTugMoeN7nq8nBYTgRlyldAgc4rk+dQnRkdd9F+lWY+uUcRXYmdDPLt2uUwLS65Sg8RIFbw6s/kvSBfhN0j2auqClLhbGQrVlRxRfqbquWCQmSS46LQGeakOepNDKiq7MgViEYX76dcoz8cxGG1d5StYMNe2XXA/Ibe5rrmRmpGilQxKZ8EYupTQ1FLxX6uY5/08WBTRXvWV021Gk16LI5ir7aGkUYGeBRU4inc/UBZ+dm/Tr+Ny+8dkJ4yyY8nAeaRrQCUU2YyqYXkha1RhaJwlbBmJF9zQo7TzzD+3oL22SOUu+4Jt3QiDjWaR7QiYXqlZ4baxA2moHoC1N/X5U7Tx1K9UlE5d421Kf8w/zxCflaeeN+eqCrqVe1Cx3Qxtd29z7/ch1SIyWSP5gIx7d6y7ehFl0O5JKybiFmZKNsl42ZbPcWbya5B8NDUdML6WGY72kmtqVPE4A3nxeYFXurqHjbI7kiOolWf07UrDctzzZIQRPSai82IVQOd3E/gcj1CGTcNaEYO+E7PXceRMijYI1IH0T6vDlwlkRwnvS+f0R6vBtwFkRguSjEbLncuF5I2pOt1HL91mnRWRXcx+KzNTma0bnvqqUfJJ1k7lHcBRY/kFY5bcip6GFOky9UzlPwk0xJ+/cQ5832r14jFdFo1SNWgIReKmi84qO07vbf2AoiiXbfwNBd/8B&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div><div class="align-center">&lt;그림 4. Scheduling points&gt;</div><p class="align-center"><img src="https://drive.google.com/uc?export=view&amp;id=1GM6EDcNwkkzy3DAO-FPyLcSnum8EF2F-" alt="" loading="lazy"> &lt;그림 5. 스케줄링 개요&gt;</p><p>시스템은 CPU와 같은 프로세서를 통해 프로세스를 실행하다가 I/O 요청이나 시분할 알고리즘, 프로세스 생성(fork child process), 인터럽트 등의 이벤트에 의해 프로세스의 상태 전이가 발생하면 스케줄러는 다음으로 실행할 프로세스를 전달(dispatch)하여 문맥 교환이 발생합니다.</p><h2 id="_4-스케줄링-성능-지표-기준-criteria" tabindex="-1"><a class="header-anchor" href="#_4-스케줄링-성능-지표-기준-criteria" aria-hidden="true">#</a> 4. 스케줄링 성능 지표(기준, Criteria)</h2><p>스케줄링 알고리즘의 성능을 평가하는 요소로 크게 5가지가 있습니다.</p><ul><li>CPU 사용률(CPU utilization) <ul><li>전체 시스템 시간 중 CPU가 작업을 처리하는 시간의 비율</li></ul></li><li>처리율(Throughput) <ul><li>단위 시간(Time unit) 당 실행 완료하는 프로세스 수</li></ul></li><li>소요 시간(Turnaround time) <ul><li>프로세스 처리 시작부터 완료까지 소요된 시간</li></ul></li><li>대기 시간(Waiting time) <ul><li>프로세스가 대기 큐(Ready queue)에 입력된 직후 실행(자원 할당 받기)까지 대기하는 시간</li></ul></li><li>응답 시간(Response time) <ul><li>프로세스 실행 요청 직후부터 결과 반환까지 소요된 시간</li></ul></li></ul><h2 id="_5-기아와-선점형-스케줄링" tabindex="-1"><a class="header-anchor" href="#_5-기아와-선점형-스케줄링" aria-hidden="true">#</a> 5. 기아와 선점형 스케줄링</h2><p>기아(Starvation)란 특정 프로세스가 실행(진행, Progress)에 필요한 자원을 다른 프로세스가 점유하고 있어 긴 시간 동안 실행되지 않는 현상을 의미합니다. 좋지 않은 스케줄링 정책은 기아 현상을 발생시킵니다.</p><p>다른 프로세스가 점유한 자원(ex. CPU)을 특정 프로세스가 가로챌 수 없는 형태의 스케줄링 정책을 비선점형(Non-preemptive) 스케줄링이라 하고, 반대로 가로챌 수 있는 스케줄링 정책을 선점형(Preemptive) 스케줄링이라 합니다. 둘의 차이를 비교하면 다음과 같습니다.</p><div class="align-center"><table><thead><tr><th style="text-align:center;">관점</th><th style="text-align:center;">비선점형 스케줄링</th><th style="text-align:center;">선점형 스케줄링</th></tr></thead><tbody><tr><td style="text-align:center;">개념</td><td style="text-align:center;">한 번 프로세스에게 자원이 할당되면 프로세스가 완료되거나 자발적으로 Waiting 상태로 전이하기 전까지 자원을 점유하고 있음</td><td style="text-align:center;">스케줄러가 기준에 따라 프로세스를 중단하고 문맥 교환을 강제할 수 있음</td></tr><tr><td style="text-align:center;">기아</td><td style="text-align:center;">실행 시간이 긴 프로세스에 의해 발생</td><td style="text-align:center;">대기 큐(Ready Queue)에 우선순위가 높은 프로세스가 자주 입력되면 우선순위가 낮은 프로세스가 기아를 겪을 수 있음</td></tr><tr><td style="text-align:center;">선점으로 인한 오버헤드</td><td style="text-align:center;">존재하지 않음</td><td style="text-align:center;">존재</td></tr><tr><td style="text-align:center;">대기 시간(Waiting Time)</td><td style="text-align:center;">(비교적)낮음</td><td style="text-align:center;">높음</td></tr><tr><td style="text-align:center;">응답 시간(Response Time)</td><td style="text-align:center;">빠름</td><td style="text-align:center;">느림</td></tr><tr><td style="text-align:center;">CPU 사용률</td><td style="text-align:center;">낮음</td><td style="text-align:center;">높음</td></tr></tbody></table><div class="align-center">&lt;표 1. Non-preemptive scheduling vs Preemptive scheduling&gt;</div></div><p>선점형 스케줄링 정책을 사용할 시 다음과 같은 것들을 고려해야 합니다.</p><ul><li>공유 데이터에 대해 업데이트 중인 프로세스가 중간에 선점되면 어떻게 처리해야 하나</li><li>System call을 실행중인 프로세스가 중간에 선점된 경우 어떻게 처리해야 하나</li></ul><h2 id="_6-스케줄링-알고리즘" tabindex="-1"><a class="header-anchor" href="#_6-스케줄링-알고리즘" aria-hidden="true">#</a> 6. 스케줄링 알고리즘</h2><p>스케줄링 정책을 구현하는 알고리즘은 다양하며 시스템이 동작하는 도메인이나 워크로드에 따라 다른 목적으로 설계되는데 간단히 분류하여 살펴보면 다음과 같습니다.</p><ul><li>공통(Commonly) <ul><li>No starvation</li><li>Fairness - 공평한 수준의 자원 공유</li><li>Balance - 시스템의 모든 요소가 busy하게 동작할 것</li></ul></li><li>배치 시스템(Batch systems) <ul><li>CPU 사용량(CPU utilization) 최대화</li></ul></li><li>반응형 시스템(Interactive systems) <ul><li>응답 시간(Response time) 최소화</li></ul></li></ul><p>스케줄링 알고리즘은 FCFS, SJF, SRTF, Priority, RR, Multilevel Queue 등이 있는데 본문에서 차례로 설명할 예정입니다.</p><h3 id="_6-1-fcfs" tabindex="-1"><a class="header-anchor" href="#_6-1-fcfs" aria-hidden="true">#</a> 6.1. FCFS</h3><p>FCFS는 First-Come, First-Served의 약자로 그 뜻대로 먼저 대기 큐에 입력된 프로세스 순으로 처리한다는 알고리즘입니다.</p><p>FCFS 스케줄링 방식은 <strong>Convoy effect</strong> 문제를 갖고 있습니다.</p><div class="custom-container info"><p class="custom-container-title">Info</p><p>Convoy effect란 처리 시간이 긴 프로세스가 대기 큐에 먼저 입력되고 그 뒤에 처리 시간이 짧은 프로세스가 입력됐을 때 앞선 프로세스의 긴 처리 시간 때문에 프로세스 전체 평균 소요 시간(Average turnaround time)이 증가하는 문제를 말합니다.</p></div><p class="align-center"><img src="https://drive.google.com/uc?export=view&amp;id=1mA0SmVzRrTVKRYK1YH1xNg5rCIAnMW-a" alt="" loading="lazy"> &lt;그림 6. FCFS 스케줄링 성능 계산&gt;</p><h3 id="_6-2-sjf" tabindex="-1"><a class="header-anchor" href="#_6-2-sjf" aria-hidden="true">#</a> 6.2. SJF</h3><p>SJF는 Shortest Job First의 약자로, 그 뜻대로 예상 CPU burst(프로세스가 CPU를 사용하는 시간, 즉 처리 시간)가 가장 작은 Job을 먼저 실행하는 스케줄링 알고리즘입니다. 먼저 실행중인 프로세스가 처리 완료됐을 때 대기 큐에 존재하는 프로세스들 중 CPU burst가 가장 작은 프로세스를 스케줄링하는 방식으로 비선점형입니다.</p><ul><li>특징 <ul><li>최소 평균 대기 시간(Miminum average waiting time)을 보장(Guarantee)하는 알고리즘임</li><li>비선점형</li><li>우선순위(Priority)를 고려한 스케줄링</li></ul></li><li>문제 <ul><li>기아 가능성 있음 <ul><li><strong>Aging</strong>, <strong>Priority boosting</strong> 기법을 이용해 해결 가능</li></ul></li><li>프로세스의 예상 처리 시간, CPU burst를 측정하는 것은 불가능 <ul><li>미래의 CPU burst를 합리적으로 추측할 수 있는 방법 필요</li></ul></li></ul></li></ul><p class="align-center"><img src="https://drive.google.com/uc?export=view&amp;id=1Mnv7DmPkm8WU8J9KfdtEgbznI7DHNS-C" alt="" loading="lazy"> &lt;그림 7. SJF 스케줄링 성능 계산&gt;</p><h3 id="_6-3-srtf" tabindex="-1"><a class="header-anchor" href="#_6-3-srtf" aria-hidden="true">#</a> 6.3. SRTF</h3><p>SRTF는 Shortest Remaining Time First의 약자로, 그 뜻대로 남은 처리 시간이 짧은 프로세스 순으로 처리하는 알고리즘입니다. 앞서 설명한 SJF 스케줄링을 선점형 방식으로 수행하는 기법입니다.</p><p>대기 큐에 새 프로세스가 입력될 때마다 대기 큐에 존재하는 모든 프로세스와 실행중인 프로세스 중 남은 처리 시간이 가장 짧은 프로세스를 선택하여 실행합니다.</p><p class="align-center"><img src="https://drive.google.com/uc?export=view&amp;id=1ZNE4MmUTntmi_7gN4JNgd9s-qajQaygQ" alt="" loading="lazy"> &lt;그림 8. SRTF 스케줄링 성능 계산&gt;</p><h3 id="rr" tabindex="-1"><a class="header-anchor" href="#rr" aria-hidden="true">#</a> RR</h3><p>실행 큐(Run Queue)가 순환형(Circular) FIFO(First-In, First-Out) 큐로 설계되어 각 Job마다 Time slice(또는 Scheduling quantum이라 함)를 할당받고 그 시간 동안 실행된 뒤 다음 프로세스로 전환되는 알고리즘입니다.</p><ul><li>여러 개의 Timer-interrupt 또는 Timer tick을 이용해 Time slice 결정</li><li>Time slice의 크기가 커지면 시스템 반응성 저하(Less responsive)</li><li>Time slice의 크기가 작아지면 문맥 교환 오버헤드 증가(Higher context-switch overhead)</li><li>Time slice의 크기는 보통 10~100ms로 정해짐 <ul><li>프로세스 실행 특징 &lt;그림 1&gt;, &lt;그림 2&gt; 근거</li></ul></li></ul><p class="align-center"><img src="https://drive.google.com/uc?export=view&amp;id=1-Chjm3R4M8SwpTHQXYWU5Sr5Rig7fOmF" alt="" loading="lazy"> &lt;그림 9. Round Robin 스케줄링&gt;</p><ul><li>특징 <ul><li>선점형</li><li>기아 X</li><li>시분할(Time-sharing)을 통한 응답 시간 향상(Improve reponse time)</li><li>대기 시간(Waiting time)은 증가함</li></ul></li></ul><h3 id="다단계-큐" tabindex="-1"><a class="header-anchor" href="#다단계-큐" aria-hidden="true">#</a> 다단계 큐</h3><p>(Multilevel Queue) 작성 예정</p><h3 id="다단계-피드백-큐" tabindex="-1"><a class="header-anchor" href="#다단계-피드백-큐" aria-hidden="true">#</a> 다단계 피드백 큐</h3><p>(Multilevel Feedback Queue) 작성 예정</p></div><!----><footer class="page-meta"><!----><div class="meta-item update-time"><span class="label">Last update: </span><!----></div><div class="meta-item contributors"><span class="label">Contributors: </span><!--[--><!--[--><span class="contributor" title="email: leesh1510@ajou.ac.kr">DrMaemi</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/blog/computer-science/operating-system/06-threads.html" class="nav-link prev" aria-label="[운영체제] 06. 스레드"><div class="hint"><span class="arrow left"></span>Prev</div><div class="link"><span class="icon iconfont icon-article"></span>[운영체제] 06. 스레드</div></a><!----></nav><div class="giscus-wrapper input-top" style="display:block;"><div style="text-align:center">Loading...</div></div><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">MIT Licensed | Copyright © 2022-present Dr.Maemi</div><!----></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/blog/assets/app.4c26a6ee.js" defer></script>
  </body>
</html>
